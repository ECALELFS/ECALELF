#include<iostream>

namespace spr {

  // One Hit Collection
  template <typename T>
  std::vector<typename T::const_iterator> findHitCone(const CaloGeometry* geo, edm::Handle<T>& hits, const GlobalPoint& hpoint1, const GlobalPoint& point1, double dR, const GlobalVector& trackMom) {
    
    std::vector<typename T::const_iterator> hit = findCone(geo, hits, hpoint1, point1, dR, trackMom);
    
    return hit;
  }
  
  // Two Hit Collections - needed for looping over Ecal Endcap/Barrel Hits
  template <typename T>
  std::vector<typename T::const_iterator> findHitCone(const CaloGeometry* geo, edm::Handle<T>& barrelhits, edm::Handle<T>& endcaphits, const GlobalPoint& hpoint1, const GlobalPoint& point1, double dR, const GlobalVector& trackMom) {
  
    std::vector<typename T::const_iterator> hit = findCone(geo, barrelhits, endcaphits, hpoint1, point1, dR, trackMom);
  
    return hit;
  }

  //Ecal Endcap OR Barrel RecHits
  std::vector<EcalRecHitCollection::const_iterator> findCone(const CaloGeometry* geo, edm::Handle<EcalRecHitCollection>& hits, const GlobalPoint& hpoint1, const GlobalPoint& point1, double dR, const GlobalVector& trackMom) {
  
    std::vector<EcalRecHitCollection::const_iterator> hit;
  
    for (EcalRecHitCollection::const_iterator j=hits->begin(); 
	 j!=hits->end(); j++) {

      bool keepHit = false;
    
      if (j->id().subdetId() == EcalEndcap) {
	EEDetId EEid = EEDetId(j->id());
	const GlobalPoint rechitPoint = geo->getPosition(EEid);
	if (getDistInPlaneTrackDir(point1, trackMom, rechitPoint)<dR) keepHit = true;
      } else if (j->id().subdetId() == EcalBarrel) {
	EBDetId EBid = EBDetId(j->id());
	const GlobalPoint rechitPoint = geo->getPosition(EBid);
	if (getDistInPlaneTrackDir(point1, trackMom, rechitPoint)<dR) keepHit = true;
      }

      if (keepHit) hit.push_back(j);
    }
    return hit;
  }

  // Ecal Endcap AND Barrel RecHits
  std::vector<EcalRecHitCollection::const_iterator> findCone(const CaloGeometry* geo, edm::Handle<EcalRecHitCollection>& barrelhits, edm::Handle<EcalRecHitCollection>& endcaphits, const GlobalPoint& hpoint1, const GlobalPoint& point1, double dR, const GlobalVector& trackMom) {
  
    std::vector<EcalRecHitCollection::const_iterator> hit;
  
    // Only check both barrel and endcap when track is near transition
    // region: 1.479-2*0.087 < trkEta < 1.479+2*0.087
  
    bool doBarrel=false, doEndcap=false;
    if ( std::abs(point1.eta()) < 1.653) doBarrel=true; // 1.479+2*0.087
    if ( std::abs(point1.eta()) > 1.305) doEndcap=true; // 1.479-2*0.087    
  
    if (doBarrel) {  
      for (EcalRecHitCollection::const_iterator j=barrelhits->begin(); 
	   j!=barrelhits->end(); j++) {

	bool keepHit = false;
	if (j->id().subdetId() == EcalBarrel) {
	  EBDetId EBid = EBDetId(j->id());
	  const GlobalPoint rechitPoint = geo->getPosition(EBid);
	  if (getDistInPlaneTrackDir(point1, trackMom, rechitPoint)<dR) keepHit = true;
	} else {
	  std::cout << "PROBLEM : Endcap RecHits in Barrel Collection!?" 
		    << std::endl;
	}
	if (keepHit) hit.push_back(j);
      }
    } // doBarrel
  
    if (doEndcap) {  
    
      for (EcalRecHitCollection::const_iterator j=endcaphits->begin(); 
	   j!=endcaphits->end(); j++) {
      
	bool keepHit = false;
      
	if (j->id().subdetId() == EcalEndcap) {
	  EEDetId EEid = EEDetId(j->id());
	  const GlobalPoint rechitPoint = geo->getPosition(EEid);
	  if (getDistInPlaneTrackDir(point1, trackMom, rechitPoint)<dR) keepHit = true;
	} else {
	  std::cout << "PROBLEM : Barrel RecHits in Endcap Collection!?" 
		    << std::endl;
	}
	if (keepHit) hit.push_back(j);
      }
    } // doEndcap
  
    return hit;
  }


  //HBHE RecHits
  std::vector<HBHERecHitCollection::const_iterator> findCone(const CaloGeometry* geo, edm::Handle<HBHERecHitCollection>& hits, const GlobalPoint& hpoint1, const GlobalPoint& point1, double dR, const GlobalVector& trackMom) {

    std::vector<HBHERecHitCollection::const_iterator> hit;
    // Loop over Hcal RecHits
    for (HBHERecHitCollection::const_iterator j=hits->begin(); 
	 j!=hits->end(); j++) {   
      DetId detId(j->id());
      const GlobalPoint rechitPoint = geo->getPosition(detId);
      if (getDistInPlaneTrackDir(hpoint1, trackMom, rechitPoint)<dR) hit.push_back(j);
    }  
    return hit;
  }

  // PCalo SimHits
  std::vector<edm::PCaloHitContainer::const_iterator> findCone(const CaloGeometry* geo, edm::Handle<edm::PCaloHitContainer>& hits, const GlobalPoint& hpoint1, const GlobalPoint& point1, double dR, const GlobalVector& trackMom) {

    std::vector<edm::PCaloHitContainer::const_iterator> hit;  
    edm::PCaloHitContainer::const_iterator ihit;
    for (ihit=hits->begin(); ihit!=hits->end(); ihit++) {
      DetId detId(ihit->id());
      const GlobalPoint rechitPoint = geo->getPosition(detId);
      if (getDistInPlaneTrackDir(hpoint1, trackMom, rechitPoint)<dR) {
	hit.push_back(ihit);
      }
    }
    return hit;
  }


  // Cone clustering core
  double getDistInPlaneTrackDir(const GlobalPoint&  caloPoint, const GlobalVector& caloVector, const GlobalPoint&  rechitPoint) {
  
    const GlobalVector caloIntersectVector(caloPoint.x(), 
					   caloPoint.y(), 
					   caloPoint.z()); //p

    const GlobalVector caloUnitVector = caloVector.unit();
    const GlobalVector rechitVector(rechitPoint.x(),
				    rechitPoint.y(),
				    rechitPoint.z());
    const GlobalVector rechitUnitVector = rechitVector.unit();
    double dotprod_denominator = caloUnitVector.dot(rechitUnitVector);
    double dotprod_numerator   = caloUnitVector.dot(caloIntersectVector);
    double rechitdist = dotprod_numerator/dotprod_denominator;
    const GlobalVector effectiveRechitVector = rechitdist*rechitUnitVector;
    const GlobalPoint effectiveRechitPoint(effectiveRechitVector.x(),
					   effectiveRechitVector.y(),
					   effectiveRechitVector.z());
    GlobalVector distance_vector = effectiveRechitPoint-caloPoint;
    if (dotprod_denominator > 0. && dotprod_numerator > 0.) {
      return distance_vector.mag();
    } else {
      return 999999.;
    }
  }

  // Not used, but here for reference
  double getDistInCMatEcal(double eta1, double phi1, double eta2, double phi2){

    double dR, Rec;
    if (fabs(eta1)<1.479) Rec=129;
    else Rec=317;
    double ce1=cosh(eta1);
    double ce2=cosh(eta2);
    double te1=tanh(eta1);
    double te2=tanh(eta2);
  
    double z=cos(phi1-phi2)/ce1/ce2+te1*te2;
    if(z!=0) dR=fabs(Rec*ce1*sqrt(1./z/z-1.));
    else     dR=999999.;
    return dR;
  }


  // Not used, but here for reference
  double getDistInCMatHcal(double eta1, double phi1, double eta2, double phi2){

    // Radii and eta from Geometry/HcalCommonData/data/hcalendcapalgo.xml
    // and Geometry/HcalCommonData/data/hcalbarrelalgo.xml

    double dR, Rec;
    if (fabs(eta1)<1.392) Rec=177.5; 
    else Rec=391.95;
    double ce1=cosh(eta1);
    double ce2=cosh(eta2);
    double te1=tanh(eta1);
    double te2=tanh(eta2);
  
    double z=cos(phi1-phi2)/ce1/ce2+te1*te2;
    if(z!=0) dR=fabs(Rec*ce1*sqrt(1./z/z-1.));
    else     dR=999999.;
    return dR;
  }

}

