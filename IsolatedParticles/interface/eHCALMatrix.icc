#include "Calibration/IsolatedParticles/interface/FindCaloHit.h"
#include "Calibration/IsolatedParticles/interface/FindEtaPhi.h"
#include "Calibration/IsolatedParticles/interface/MatrixHCALDetIds.h"
#include "DataFormats/HcalDetId/interface/HcalSubdetector.h"
#include<iostream>

namespace spr{

  //*** Returns energy in NxN Hcal towers
  template <typename T>
  double eHCALmatrix(const HcalTopology* topology, const DetId& det0, edm::Handle<T>& hits, int ieta, int iphi, bool includeHO, bool algoNew, bool debug) {

    std::vector< typename T::const_iterator> hit;
    HcalDetId hcid0(det0.rawId());
    HcalDetId hcid(hcid0.subdet(),hcid0.ieta(),hcid0.iphi(),1);
    DetId det(hcid.rawId());
    if (debug) std::cout << "Inside eHCALmatrix " << 2*ieta+1 << "X" << 2*iphi+1 << " AlgoNew " << algoNew << " Inclusion of HO Flag " << includeHO << std::endl;
    if (algoNew) {
      hit = spr::hitHCALmatrixNew(topology, det, hits, ieta, iphi, includeHO, debug);
    } else {
      hit = spr::hitHCALmatrix(topology, det, hits, ieta, iphi, includeHO, debug);
    }
    if (debug) {
      std::cout << "eHCALmatrix:: # of HcalTowers " << hit.size() << " ";
      for (unsigned int ihit=0; ihit<hit.size(); ihit++) 
        std::cout <<" ihit:" << ihit << " " << (unsigned int)hit[ihit]->id();
      std::cout << "\n" << std::endl;
    }

    double energySum = 0.0;
    for (unsigned int ihit=0; ihit<hit.size(); ihit++) {
      energySum += hit[ihit]->energy();
    }

    if (debug) std::cout << "eHCALmatrix::Total energy " << energySum << std::endl;
    return energySum;
  }

  template <typename T>
  std::vector< std::pair< DetId,double> > eHCALmatrix(const HcalTopology* topology, const DetId& det, edm::Handle<T>& hits, int ieta, int iphi, bool includeHO, bool debug) {

    std::vector<DetId> dets(1,det);
    std::vector<DetId> vdets = spr::matrixHCALIds(dets, topology, ieta, iphi, debug);
    return spr::energyDetIdHCALneighbours(vdets, topology, hits, includeHO, debug);
  }

  template <typename T>
  double eHCALmatrix(const HcalTopology* topology, const DetId& det0, edm::Handle<T>& hits, int ietaE, int ietaW, int iphiN, int iphiS, bool includeHO, bool debug) {

    HcalDetId hcid0(det0.rawId());
    HcalDetId hcid(hcid0.subdet(),hcid0.ieta(),hcid0.iphi(),1);
    DetId det(hcid.rawId());
    if (debug) std::cout << "Inside eHCALmatrix " << ietaE+ietaW+1 << "X" << iphiN+iphiS+1 	<< " Inclusion of HO Flag " << includeHO << std::endl;

    std::vector< typename T::const_iterator>  hit = spr::hitHCALmatrixTotal(topology, det, hits, ietaE, ietaW, iphiN, iphiS, includeHO, debug);
    if (debug) {
      std::cout << "eHCALmatrix:: # of HcalTowers " << hit.size() << " ";
      for (unsigned int ihit=0; ihit<hit.size(); ihit++) 
        std::cout <<" ihit:" << ihit << " " << (unsigned int)hit[ihit]->id();
      std::cout << "\n" << std::endl;
    }

    double energySum = 0.0;
    for (unsigned int ihit=0; ihit<hit.size(); ihit++) {
      energySum += hit[ihit]->energy();
    }

    if (debug) std::cout << "eHCALmatrix::Total energy " << energySum << std::endl;
    return energySum;
  }

  //*** Returns energy in NxN Hcal towers
  template <typename T>
  std::pair<double,int> eHCALmatrixTotal(const HcalTopology* topology, const DetId& det0, edm::Handle<T>& hits, int ieta, int iphi, bool includeHO, bool debug) {

    HcalDetId hcid0(det0.rawId());
    HcalDetId hcid(hcid0.subdet(),hcid0.ieta(),hcid0.iphi(),1);
    DetId det(hcid.rawId());
    if (debug) std::cout << "Inside eHCALmatrixTotal " << ieta << "X" << iphi << " Inclusion of HO Flag " << includeHO << std::endl;

    spr::EtaPhi etaphi = spr::getEtaPhi(ieta,iphi,debug);

    // Get maximum of all the trials
    double energySum = 0;
    int    itrym = 0;
    for (int itry=0; itry<etaphi.ntrys; itry++) {
      std::vector< typename T::const_iterator> hit = hitHCALmatrixTotal(topology, det, hits, etaphi.ietaE[itry], etaphi.ietaW[itry], etaphi.iphiN[itry], etaphi.iphiS[itry], includeHO, debug);
      if (debug) {
        std::cout << "eHCALmatrixTotal:: # of HcalTowers " << hit.size() <<" ";
        for (unsigned int ihit=0; ihit<hit.size(); ihit++) 
          std::cout <<" ihit:" << ihit << " " << (unsigned int)hit[ihit]->id();
        std::cout << "\n" << std::endl;
      }
      double energy = 0;
      for (unsigned int ihit=0; ihit<hit.size(); ihit++) {
        energy += hit[ihit]->energy();
      }
      if (energy > energySum) {
        energySum = energy;
        itrym     = itry;
      }
      if (debug) std::cout << "eHCALMatrix::Total energy " << energy << " Max " << energySum << "in trial # " << itrym << std::endl;
    }

    return std::pair<double,int>(energySum,itrym);
  }


  //*** Returns vector of hits in 3x3 or 5x5 Hcal towers
  template <typename T>
  std::vector<typename T::const_iterator> hitHCALmatrix(const HcalTopology* topology, const DetId& det, edm::Handle<T>& hits, int ieta, int iphi, bool includeHO, bool debug) {

    std::vector< typename T::const_iterator> hit, hitlist;
  
    if (ieta > 2) {
      std::cout <<" no matrix > 5x5 is coded ! " << std::endl;
      return hitlist;
    }
    // used dets during building the matrix
    std::vector<DetId> dets;
    dets.clear();

    // central tower
    std::vector<DetId> vNeighboursDetId;
    vNeighboursDetId.push_back(det);
  
    hit = hitHCALneighbours(vNeighboursDetId, dets, topology, hits,
	                    includeHO, debug);
    hitlist.insert(hitlist.end(), hit.begin(), hit.end());

    if (ieta > 0) {
      // go to east from central tower 
      vNeighboursDetId.clear();
      if (debug) std::cout << "hitHCALMatrix:: det " << (HcalDetId)det << std::endl;
      vNeighboursDetId = topology->east(det);
      if (debug) {
        std::cout << "Neighbour:: East";
        for (unsigned int i=0; i<vNeighboursDetId.size(); i++)
          std::cout << " " << (HcalDetId)vNeighboursDetId[i];
        std::cout << std::endl;
      }
    
      hit = hitHCALneighbours(vNeighboursDetId, dets, topology, hits,
	                      includeHO, debug);
      hitlist.insert(hitlist.end(), hit.begin(), hit.end());
      if (ieta == 2) {
        for (int ii = 0; ii < (int) vNeighboursDetId.size(); ii++) {
	  std::vector<DetId> vNeighboursDetIdc = topology->east(vNeighboursDetId[ii]);
          if (debug) {
            std::cout << "Neighbour:: East";
            for (unsigned int i=0; i<vNeighboursDetIdc.size(); i++)
              std::cout << " " << (HcalDetId)vNeighboursDetIdc[i];
            std::cout << std::endl;
          }

	  hit = hitHCALneighbours(vNeighboursDetIdc, dets, topology, hits,
	                          includeHO, debug);
	  hitlist.insert(hitlist.end(), hit.begin(), hit.end());
        }
      }

      // go to west from central tower 
      vNeighboursDetId.clear();
      vNeighboursDetId = topology->west(det);
      if (debug) {
        std::cout << "Neighbour:: West";
        for (unsigned int i=0; i<vNeighboursDetId.size(); i++)
          std::cout << " " << (HcalDetId)vNeighboursDetId[i];
        std::cout << std::endl;
      }

      hit = hitHCALneighbours(vNeighboursDetId, dets, topology, hits,
	                      includeHO, debug);
      hitlist.insert(hitlist.end(), hit.begin(), hit.end());
      if (ieta == 2) {
        for (int ii = 0; ii < (int) vNeighboursDetId.size(); ii++) {
	  std::vector<DetId> vNeighboursDetIdc = topology->west(vNeighboursDetId[ii]);
          if (debug) {
            std::cout << "Neighbour:: West";
            for (unsigned int i=0; i<vNeighboursDetIdc.size(); i++)
              std::cout << " " << (HcalDetId)vNeighboursDetIdc[i];
            std::cout << std::endl;
          }

	  hit = hitHCALneighbours(vNeighboursDetIdc, dets, topology, hits,
	                          includeHO, debug);
	  hitlist.insert(hitlist.end(), hit.begin(), hit.end());
        }
      }
    }
  
    // do steps in phi to north
    DetId detnorth = det;
    for (int inorth = 0; inorth < iphi; inorth++) {
      if (debug) std::cout << "hitHCALMatrix:: detNorth " << (HcalDetId)detnorth << std::endl;
      std::vector<DetId> NorthDetId = topology->north(detnorth);
      if (debug) {
        std::cout << "Neighbour:: North";
        for (unsigned int i=0; i<NorthDetId.size(); i++)
          std::cout << " " << (HcalDetId)NorthDetId[i];
        std::cout << std::endl;
      }

      if (NorthDetId.size() > 0) {
        hit = hitHCALneighbours(NorthDetId, dets, topology, hits,
	                        includeHO, debug);
        hitlist.insert(hitlist.end(), hit.begin(), hit.end());

        if (ieta>0) {
  	  // go to east  
	  vNeighboursDetId.clear();
	  vNeighboursDetId = topology->east(NorthDetId[0]);
          if (debug) {
  	    std::cout << "Neighbour:: East";
	    for (unsigned int i=0; i<vNeighboursDetId.size(); i++)
	      std::cout << " " << (HcalDetId)vNeighboursDetId[i];
	    std::cout << std::endl;
	  }

	  hit = hitHCALneighbours(vNeighboursDetId, dets, topology, hits,
	                          includeHO, debug);
	  hitlist.insert(hitlist.end(), hit.begin(), hit.end());
	  if (ieta == 2) {
	    for (int ii = 0; ii < (int) vNeighboursDetId.size(); ii++) {
	      std::vector<DetId> vNeighboursDetIdc = topology->east(vNeighboursDetId[ii]);
              if (debug) {
  	        std::cout << "Neighbour:: East";
                for (unsigned int i=0; i<vNeighboursDetIdc.size(); i++)
	          std::cout << " " << (HcalDetId)vNeighboursDetIdc[i];
	        std::cout << std::endl;
	      }

	      hit = hitHCALneighbours(vNeighboursDetIdc, dets, topology, hits,
	                              includeHO, debug);
	      hitlist.insert(hitlist.end(), hit.begin(), hit.end());
	    }
	  }

	  // go to west 
	  vNeighboursDetId.clear();
	  vNeighboursDetId = topology->west(NorthDetId[0]);
          if (debug) {
	    std::cout << "Neighbour:: West";
	    for (unsigned int i=0; i<vNeighboursDetId.size(); i++)
	      std::cout << " " << (HcalDetId)vNeighboursDetId[i];
	    std::cout << std::endl;
	  }

	  hit = hitHCALneighbours(vNeighboursDetId, dets, topology, hits,
	                          includeHO, debug);
	  hitlist.insert(hitlist.end(), hit.begin(), hit.end());

	  if (ieta == 2) {
	    for (int ii = 0; ii < (int) vNeighboursDetId.size(); ii++) {
	      std::vector<DetId> vNeighboursDetIdc = topology->west(vNeighboursDetId[ii]);
              if (debug) {
	        std::cout << "Neighbour:: West";
	        for (unsigned int i=0; i<vNeighboursDetIdc.size(); i++)
	          std::cout << " " << (HcalDetId)vNeighboursDetIdc[i];
	        std::cout << std::endl;
	      }

	      hit = hitHCALneighbours(vNeighboursDetIdc, dets, topology, hits,
	                              includeHO, debug);
	      hitlist.insert(hitlist.end(), hit.begin(), hit.end());
	    }
	  }
        }
        detnorth = NorthDetId[0];
      } else {
        break;
      }
    }

    // do steps in phi to south
    DetId detsouth = det;
    for (int isouth = 0; isouth < iphi; isouth++) {
      if (debug) std::cout << "hitHCALMatrix:: detSouth " << (HcalDetId)detsouth << std::endl;    
      vNeighboursDetId.clear();
      std::vector<DetId> SouthDetId = topology->south(detsouth);
      if (SouthDetId.size()>0) {
        hit = hitHCALneighbours(SouthDetId, dets, topology, hits,
	                        includeHO, debug);
        hitlist.insert(hitlist.end(), hit.begin(), hit.end());
      
        if (debug) {
          std::cout << "Neighbour:: South";
          for (unsigned int i=0; i<SouthDetId.size(); i++)
            std::cout << " " << (HcalDetId)SouthDetId[i];
          std::cout << std::endl;
        }
 
        // go to east  
        if (ieta > 0) {
	  // go to east from central tower 
	  vNeighboursDetId.clear();
	  vNeighboursDetId = topology->east(SouthDetId[0]);
          if (debug) {
	    std::cout << "Neighbour:: East";
	    for (unsigned int i=0; i<vNeighboursDetId.size(); i++)
	      std::cout << " " << (HcalDetId)vNeighboursDetId[i];
	    std::cout << std::endl;
	  }

	  hit = hitHCALneighbours(vNeighboursDetId, dets, topology, hits,
	                          includeHO, debug);
	  hitlist.insert(hitlist.end(), hit.begin(), hit.end());
	  if (ieta == 2) {
	    for (int ii = 0; ii < (int) vNeighboursDetId.size(); ii++) {
	      std::vector<DetId> vNeighboursDetIdc = topology->east(vNeighboursDetId[ii]);
              if (debug) {
	        std::cout << "Neighbour:: East";
	        for (unsigned int i=0; i<vNeighboursDetIdc.size(); i++)
	          std::cout << " " << (HcalDetId)vNeighboursDetIdc[i];
	        std::cout << std::endl;
	      }

	      hit = hitHCALneighbours(vNeighboursDetIdc, dets, topology, hits,
	                              includeHO, debug);
	      hitlist.insert(hitlist.end(), hit.begin(), hit.end());
	    }
	  }

	  // go to west 
	  vNeighboursDetId.clear();
	  vNeighboursDetId = topology->west(SouthDetId[0]);
          if (debug) {
	    std::cout << "Neighbour:: West";
	    for (unsigned int i=0; i<vNeighboursDetId.size(); i++)
	      std::cout << " " << (HcalDetId)vNeighboursDetId[i];
	    std::cout << std::endl;
	  }

	  hit = hitHCALneighbours(vNeighboursDetId, dets, topology, hits,
	                          includeHO, debug);
	  hitlist.insert(hitlist.end(), hit.begin(), hit.end());
	  if (ieta == 2) {
	    for (int ii = 0; ii < (int) vNeighboursDetId.size(); ii++) {
	      std::vector<DetId> vNeighboursDetIdc = topology->west(vNeighboursDetId[ii]);
              if (debug) {
	        std::cout << "Neighbour:: West";
	        for (unsigned int i=0; i<vNeighboursDetIdc.size(); i++)
	          std::cout << " " << (HcalDetId)vNeighboursDetIdc[i];
	        std::cout << std::endl;
	      }

	      hit = hitHCALneighbours(vNeighboursDetIdc, dets, topology, hits,
	                              includeHO, debug);
	      hitlist.insert(hitlist.end(), hit.begin(), hit.end());
	    }
	  }
        }
        detsouth = SouthDetId[0];
      } else {
        break;
      }
    }

    return hitlist;
  }

  //*** Returns energy in beyond 5x5 Hcal towers
  template <typename T>
  std::vector<typename T::const_iterator> hitHCALmatrixNew(const HcalTopology* topology, const DetId& det, edm::Handle<T>& hits, int ieta, int iphi, bool includeHO, bool debug) {

    std::vector<DetId> dets(1,det);
    std::vector<DetId> vdets = spr::matrixHCALIds(dets, topology, ieta, iphi, debug);
    return spr::hitHCALneighbours(vdets, topology, hits, includeHO, debug);
  }

  template <typename T>
  std::vector<typename T::const_iterator> hitHCALmatrixTotal(const HcalTopology* topology, const DetId& det, edm::Handle<T>& hits, int ietaE, int ietaW, int iphiN, int iphiS, bool includeHO, bool debug) {

    std::vector<DetId> dets(1,det);
    std::vector<DetId> vdets = spr::matrixHCALIds(dets, topology, ietaE, ietaW, iphiN, iphiS, debug);
    return spr::hitHCALneighbours(vdets, topology, hits, includeHO, debug);
  }

  template <typename T>
  std::vector<typename T::const_iterator> hitHCALneighbours(std::vector<DetId>& vNeighboursDetId, std::vector<DetId>& dets, const HcalTopology* topology, edm::Handle<T>& hits, bool includeHO, bool debug) {

    std::vector< typename T::const_iterator> hit, hitlist;
 
    for(int i = 0; i < (int) vNeighboursDetId.size(); i++) {
      int n = std::count(dets.begin(),dets.end(),vNeighboursDetId[i]);
      if (n != 0) continue; 
      dets.push_back(vNeighboursDetId[i]);
      hit = spr::findHit(hits, vNeighboursDetId[i]);

      for (unsigned int ihit=0; ihit<hit.size(); ihit++) {
        if (hit[ihit] != hits->end()) hitlist.push_back(hit[ihit]);
      }

      HcalDetId depth = vNeighboursDetId[i];
      // max. three depths can be in endcap and we go to 2nd and 3rd from 1st where we are now
      for (int idepth = 0; idepth < 2; idepth++) {
        std::vector<DetId> vUpDetId = topology->up(depth);
        if (vUpDetId.size() != 0) {
	  if (includeHO || vUpDetId[0].subdetId() != (int)(HcalOuter)) {
	    int n = std::count(dets.begin(),dets.end(),vUpDetId[0]);
	    if (n == 0) {
	      dets.push_back(vUpDetId[0]);
	      hit = spr::findHit(hits, vUpDetId[0]);

	      for (unsigned int ihit=0; ihit<hit.size(); ihit++) {
	        if (hit[ihit] != hits->end()) hitlist.push_back(hit[ihit]);
	      }
	    }
          }
	  depth = vUpDetId[0];
        }
      }

    }
    if (debug) std::cout << "hitHCALneighbour " << hitlist.size() << std::endl;
    return hitlist;
  }

  template <typename T>
  std::vector<typename T::const_iterator> hitHCALneighbours(std::vector<DetId>& vdets, const HcalTopology* topology, edm::Handle<T>& hits, bool includeHO, bool debug) {

    std::vector< typename T::const_iterator> hit, hitlist;

    int khit = 0;
    unsigned int maxsize = vdets.size();
    for (unsigned int i=0; i<maxsize; i++) {
      hit = spr::findHit(hits, vdets[i]);
      for (unsigned int ihit=0; ihit<hit.size(); ihit++) {
        if (hit[ihit] != hits->end()) {
          hitlist.push_back(hit[ihit]);
	  khit++;
	  if (debug) std::cout << "hitHCALneighbours:: Hit " << khit << " " << (HcalDetId)vdets[i] << std::endl;
        }
      }

      HcalDetId vdet = vdets[i];
      for (int idepth = 0; idepth < 3; idepth++) {
        std::vector<DetId> vUpDetId = topology->up(vdet);
        if (vUpDetId.size() != 0) {
          if (includeHO || vUpDetId[0].subdetId() != (int)(HcalOuter)) {
            int n = std::count(vdets.begin(),vdets.end(),vUpDetId[0]);
            if (n == 0) {
	      if (debug) std::cout << "hitHCALneighbours:: Depth " << idepth << " " << vdet << " " << (HcalDetId)vUpDetId[0] << std::endl;
              vdets.push_back(vUpDetId[0]);
              hit = spr::findHit(hits, vUpDetId[0]);
              for (unsigned int ihit=0; ihit<hit.size(); ihit++) {
                if (hit[ihit] != hits->end()) {
	          hitlist.push_back(hit[ihit]);
  	          khit++;
	          if (debug) std::cout << "hitHCALneighbours:: Hit " << khit << " " << (HcalDetId)vUpDetId[0] << std::endl;
                }
              }
            }
          }
          vdet = vUpDetId[0];
        }
      }
    }

    if (debug) std::cout << "hitHCALneighbours::Hit buffer size " 
                         << hitlist.size() << std::endl;
    return hitlist;
  }


  template <typename T>
  std::vector<std::pair<DetId,double> > energyDetIdHCALneighbours(std::vector<DetId>& vdets, const HcalTopology* topology, edm::Handle<T>& hits, bool includeHO, bool debug) {

    std::vector< std::pair<DetId,double> >   energyDetId;
    std::vector< typename T::const_iterator> hit;

    int khit = 0;
    unsigned int maxsize = vdets.size();
    for (unsigned int i=0; i<maxsize; i++) {
      hit = spr::findHit(hits, vdets[i]);
      double energy = 0;
      for (unsigned int ihit=0; ihit<hit.size(); ihit++) {
        if (hit[ihit] != hits->end()) {
          energy += hit[ihit]->energy();
 	  khit++;
	  if (debug) std::cout << "energyDetIdHCALneighbours:: Hit " << khit << " " << (HcalDetId)vdets[i] << " energy " << hit[ihit]->energy() << std::endl;
        }
      }
      if (debug) std::cout << "energyDetIdHCALneighbours::Detector " << i << " " << (HcalDetId)vdets[i] << " energy " << energy << std::endl;
      energyDetId.push_back(std::pair<DetId,double>(vdets[i], energy));

      HcalDetId vdet = vdets[i];
      for (int idepth = 0; idepth < 3; idepth++) {
        std::vector<DetId> vUpDetId = topology->up(vdet);
        if (vUpDetId.size() != 0) {
          if (includeHO || vUpDetId[0].subdetId() != (int)(HcalOuter)) {
            int n = std::count(vdets.begin(),vdets.end(),vUpDetId[0]);
            if (n == 0) {
	      if (debug) std::cout << "energyDetIdHCALneighbours:: Depth " << idepth << " " << vdet << " " << (HcalDetId)vUpDetId[0] << std::endl;
              vdets.push_back(vUpDetId[0]);
              double energy = 0;
              hit = spr::findHit(hits, vUpDetId[0]);
              for (unsigned int ihit=0; ihit<hit.size(); ihit++) {
                if (hit[ihit] != hits->end()) {
                  energy += hit[ihit]->energy();
  	          khit++;
	          if (debug) std::cout << "energyDetIdHCALneighbours:: Hit " << khit << " " << (HcalDetId)vUpDetId[0] << " energy " << hit[ihit]->energy() << std::endl;
                }
              }
              if (debug) std::cout << "energyDetIdHCALneighbours::Detector " << i << " " << (HcalDetId)vUpDetId[0] << " energy " << energy << std::endl;
              energyDetId.push_back(std::pair<DetId,double>(vUpDetId[0], energy));
            }
          }
          vdet = vUpDetId[0];
        }
      }
    }

    if (debug) std::cout << "energyDetIdHCALneighbours::EnergyDetId buffer size " << energyDetId.size() << std::endl;
    return energyDetId;
  }

}

