#include "Calibration/IsolatedParticles/interface/MatchingSimTrack.h"
#include "Calibration/IsolatedParticles/interface/eHCALMatrix.h"
#include "Calibration/IsolatedParticles/interface/eECALMatrix.h"
#include "DataFormats/HcalDetId/interface/HcalSubdetector.h"
#include<iostream>

namespace spr{

  template <typename T>
  std::map<std::string,double> eECALSimInfo(const edm::Event& iEvent, CaloNavigator<DetId>& navigator, const CaloGeometry* geo, edm::Handle<T>& hits, edm::Handle<edm::SimTrackContainer>& SimTk, edm::Handle<edm::SimVertexContainer>& SimVtx, const reco::Track* pTrack, TrackerHitAssociator& associate, int ieta, int iphi, double timeCut, bool debug) {

    if (debug)
      std::cout << "Processing eECALSimInfo " << 2*ieta+1 << "x"<< 2*iphi+1 << "\ntrkMom " << pTrack->p() << " eta " << pTrack->eta() << " trkRecHits " << pTrack->recHitsSize() << std::endl;

    //matching SimTrack
    edm::SimTrackContainer::const_iterator trkInfo = spr::matchedSimTrack(iEvent, SimTk, SimVtx, pTrack, associate, debug);
    //vector of Ecal hits in NxN
    std::vector< typename T::const_iterator> ecalHits   = spr::hitECALmatrix(navigator,hits,ieta,iphi,debug);

    // return a map of matching type and energy of SimHits
    return spr::eCaloSimInfo(geo, hits, SimTk, SimVtx, ecalHits, trkInfo, timeCut, debug);
  }

  template <typename T>
  std::map<std::string,double> eECALSimInfo(const edm::Event& iEvent, const DetId& det, const CaloGeometry* geo, const CaloTopology* caloTopology, edm::Handle<T>& hitsEB, edm::Handle<T>& hitsEE, edm::Handle<edm::SimTrackContainer>& SimTk, edm::Handle<edm::SimVertexContainer>& SimVtx, const reco::Track* pTrack, TrackerHitAssociator& associate, int ieta, int iphi, double timeCut, bool debug) {

    if (debug)
      std::cout << "Processing eECALSimInfo " << 2*ieta+1 << "x" << 2*iphi+1 << "\ntrkMom " << pTrack->p() << " eta " << pTrack->eta() << " trkRecHits " << pTrack->recHitsSize() << std::endl;

    //matching SimTrack
    edm::SimTrackContainer::const_iterator trkInfo = spr::matchedSimTrack(iEvent, SimTk, SimVtx, pTrack, associate, debug);

    //vector of Ecal cells in NxN
    std::vector<DetId> vdets = spr::matrixECALIds(det, ieta, iphi, geo, caloTopology, debug);

    // return a map of matching type and energy of SimHits
    return spr::eCaloSimInfo(vdets, geo, hitsEB, hitsEE, SimTk, SimVtx, trkInfo, timeCut, debug);
  }

  template <typename T>
  std::map<std::string,double> eECALSimInfo(const edm::Event& iEvent, const DetId& det, const CaloGeometry* geo, const CaloTopology* caloTopology, edm::Handle<T>& hitsEB, edm::Handle<T>& hitsEE, edm::Handle<edm::SimTrackContainer>& SimTk, edm::Handle<edm::SimVertexContainer>& SimVtx, const reco::Track* pTrack, TrackerHitAssociator& associate, int ietaE, int ietaW, int iphiN, int iphiS, double timeCut, bool debug) {

    if (debug)
      std::cout << "Processing eECALSimInfo " << ietaE+ietaW+1 << "x" << iphiN+iphiS+1 << "\ntrkMom " << pTrack->p() << " eta " << pTrack->eta() << " trkRecHits " << pTrack->recHitsSize() << std::endl;

    //matching SimTrack
    edm::SimTrackContainer::const_iterator trkInfo = spr::matchedSimTrack(iEvent, SimTk, SimVtx, pTrack, associate, debug);

    //vector of Ecal cells in NxN
    std::vector<DetId> vdets = spr::matrixECALIds(det, ietaE, ietaW, iphiN, iphiS, geo, caloTopology, debug);

    // return a map of matching type and energy of SimHits
    return spr::eCaloSimInfo(vdets, geo, hitsEB, hitsEE, SimTk, SimVtx, trkInfo, timeCut, debug);
  }

  template <typename T>
  std::map<std::string,double> eECALSimInfoTotal(const edm::Event& iEvent, const DetId& det, const CaloGeometry* geo, const CaloTopology* caloTopology, edm::Handle<T>& hitsEB, edm::Handle<T>& hitsEE, edm::Handle<edm::SimTrackContainer>& SimTk, edm::Handle<edm::SimVertexContainer>& SimVtx, const reco::Track* pTrack, TrackerHitAssociator& associate, int ieta, int iphi, int itry, double timeCut, bool debug) {

    if (debug)
      std::cout << "Processing eECALSimInfo " << 2*ieta+1 << "x" << 2*iphi+1 << "\ntrkMom " << pTrack->p() << " eta " << pTrack->eta() << " trkRecHits " << pTrack->recHitsSize() << std::endl;

    //matching SimTrack
    edm::SimTrackContainer::const_iterator trkInfo = spr::matchedSimTrack(iEvent, SimTk, SimVtx, pTrack, associate, debug);

    spr::EtaPhi etaphi = spr::getEtaPhi(ieta,iphi,debug);
    std::map<std::string, double> simInfo;

    if (itry >= 0) {
      //vector of Ecal cells in NxN
      std::vector<DetId> vdets = spr::matrixECALIds(det, etaphi.ietaE[itry], etaphi.ietaW[itry], etaphi.iphiN[itry], etaphi.iphiS[itry], geo, caloTopology, debug);
      // get a map of matching type and energy of SimHits
      simInfo = spr::eCaloSimInfo(vdets, geo, hitsEB, hitsEE, SimTk, SimVtx, trkInfo, timeCut, debug);
    } else {
      int itrym = 0;
      std::vector<DetId> vdets = spr::matrixECALIds(det, etaphi.ietaE[itrym], etaphi.ietaW[itrym], etaphi.iphiN[itrym], etaphi.iphiS[itrym], geo, caloTopology, debug);
      // get a map of matching type and energy of SimHits
      simInfo = spr::eCaloSimInfo(vdets, geo, hitsEB, hitsEE, SimTk, SimVtx, trkInfo, timeCut, debug);
      for (int itrys=1; itrys<etaphi.ntrys; ++itrys) {
        vdets = spr::matrixECALIds(det, etaphi.ietaE[itrys], etaphi.ietaW[itrys], etaphi.iphiN[itrys], etaphi.iphiS[itrys], geo, caloTopology, debug);
        // get a map of matching type and energy of SimHits
        std::map<std::string, double> simInfoX = spr::eCaloSimInfo(vdets, geo, hitsEB, hitsEE, SimTk, SimVtx, trkInfo, timeCut, debug);
        if (simInfoX["eTotal"] > simInfo["eTotal"]) {
	  simInfo = simInfoX;
          itrym   = itrys;
        }
      }
    }
    return simInfo;
  }

  template <typename T>
  std::map<std::string,double> eHCALSimInfo(const edm::Event& iEvent, const HcalTopology* topology, const DetId& det, const CaloGeometry* geo, edm::Handle<T>& hits,edm::Handle<edm::SimTrackContainer>& SimTk, edm::Handle<edm::SimVertexContainer>& SimVtx, const reco::Track* pTrack, TrackerHitAssociator& associate, int ieta, int iphi, double timeCut, bool debug) {

    if (debug)
      std::cout << "Processing eHCALSimInfo " << 2*ieta+1 << "x" << 2*iphi+1 << "\ntrkMom " << pTrack->p() << " eta " << pTrack->eta() << " trkRecHits " << pTrack->recHitsSize() << std::endl;

    // get the matching SimTrack pointer
    edm::SimTrackContainer::const_iterator trkInfo = spr::matchedSimTrack(iEvent, SimTk, SimVtx, pTrack,associate, debug);

    // get the hits in Hcal in NxN around det
    std::vector< typename T::const_iterator> hit = spr::hitHCALmatrixNew(topology,det,hits,ieta,iphi,false, debug);

    return spr::eCaloSimInfo(geo, hits, SimTk, SimVtx, hit, trkInfo, timeCut, debug);
  }

  template <typename T>
  std::map<std::string,double> eHCALSimInfo(const edm::Event& iEvent, const HcalTopology* topology, const DetId& det, const CaloGeometry* geo, edm::Handle<T>& hits,edm::Handle<edm::SimTrackContainer>& SimTk, edm::Handle<edm::SimVertexContainer>& SimVtx, const reco::Track* pTrack, TrackerHitAssociator& associate, int ietaE, int ietaW, int iphiN, int iphiS, double timeCut, bool debug) {

    if (debug)
      std::cout << "Processing eHCALSimInfo " << ietaE+ietaW+1 << "x"<< iphiN+iphiS+1 << "\ntrkMom " << pTrack->p() << " eta " << pTrack->eta() << " trkRecHits " << pTrack->recHitsSize() << std::endl;

    // get the matching SimTrack pointer
    edm::SimTrackContainer::const_iterator trkInfo = spr::matchedSimTrack(iEvent, SimTk, SimVtx, pTrack,associate, debug);

    // get the hits in Hcal in NxN around det
    std::vector< typename T::const_iterator> hit = spr::hitHCALmatrixTotal(topology,det,hits,ietaE,ietaW,iphiN,iphiS,false,debug);

    return spr::eCaloSimInfo(geo, hits, SimTk, SimVtx, hit, trkInfo, timeCut, debug);
  }

  template <typename T>
  std::map<std::string,double> eHCALSimInfoTotal(const edm::Event& iEvent, const HcalTopology* topology, const DetId& det, const CaloGeometry* geo, edm::Handle<T>& hits,edm::Handle<edm::SimTrackContainer>& SimTk, edm::Handle<edm::SimVertexContainer>& SimVtx, const reco::Track* pTrack, TrackerHitAssociator& associate, int ieta, int iphi, int itry, double timeCut, bool debug) {

    if (debug)
      std::cout << "Processing eHCALSimInfo " << 2*ieta+1 << "x" << 2*iphi+1 << "\ntrkMom " << pTrack->p() << " eta " << pTrack->eta() << " trkRecHits " << pTrack->recHitsSize() << std::endl;

    // get the matching SimTrack pointer
    edm::SimTrackContainer::const_iterator trkInfo = spr::matchedSimTrack(iEvent, SimTk, SimVtx, pTrack,associate, debug);

    spr::EtaPhi etaphi = spr::getEtaPhi(ieta,iphi,debug);
    std::map<std::string, double> simInfo;

    if (itry >= 0) {
      // get the hits in Hcal in NxN around det
      std::vector< typename T::const_iterator> hit = spr::hitHCALmatrixTotal(topology,det,hits,etaphi.ietaE[itry],etaphi.ietaW[itry],etaphi.iphiN[itry],etaphi.iphiS[itry],false, debug);
      simInfo = spr::eCaloSimInfo(geo, hits, SimTk, SimVtx, hit, trkInfo, timeCut, debug);
    } else {
      int itrym = 0;
      std::vector< typename T::const_iterator> hit = spr::hitHCALmatrixTotal(topology,det,hits,etaphi.ietaE[itrym],etaphi.ietaW[itrym],etaphi.iphiN[itrym],etaphi.iphiS[itrym],false, debug);
      simInfo = spr::eCaloSimInfo(geo, hits, SimTk, SimVtx, hit, trkInfo, timeCut, debug);
      for (int itrys = 1; itrys < etaphi.ntrys; ++itrys) {
	hit = spr::hitHCALmatrixTotal(topology,det,hits,etaphi.ietaE[itrys],etaphi.ietaW[itrys],etaphi.iphiN[itrys],etaphi.iphiS[itrys],false, debug);
        std::map<std::string, double> simInfoX = spr::eCaloSimInfo(geo, hits, SimTk, SimVtx, hit, trkInfo, timeCut, debug);
        if (simInfoX["eTotal"] > simInfo["eTotal"]) {
	  simInfo = simInfoX;
          itrym   = itrys;
        }
      }
    }
    return simInfo;
  }

  template <typename T>
  std::map<std::string,double> eCaloSimInfo(std::vector<DetId> vdets, const CaloGeometry* geo, edm::Handle<T>& hitsEB, edm::Handle<T>& hitsEE,  edm::Handle<edm::SimTrackContainer>& SimTk, edm::Handle<edm::SimVertexContainer>& SimVtx, edm::SimTrackContainer::const_iterator trkInfo, double timeCut, bool debug){

    std::vector< typename T::const_iterator> hitEB, hitEE, hit;
    for (unsigned int i1=0; i1<vdets.size(); i1++) {
      if (vdets[i1] != DetId(0)) {
        if (vdets[i1].subdetId()==EcalBarrel) {
          hit = spr::findHit(hitsEB,vdets[i1]);
          for (unsigned int i2=0; i2<hit.size(); i2++) {
            if (std::count(hitEB.begin(),hitEB.end(),hit[i2]) == 0)
              hitEB.push_back(hit[i2]);
          }
        } else if (vdets[i1].subdetId()==EcalEndcap) {
          hit = spr::findHit(hitsEE,vdets[i1]);
          for (unsigned int i2=0; i2<hit.size(); i2++) {
            if (std::count(hitEE.begin(),hitEE.end(),hit[i2]) == 0)
              hitEE.push_back(hit[i2]);
          }
        }
      }
    }

    std::map<std::string,double> eEBSimInfo = spr::eCaloSimInfo(geo, hitsEB, SimTk, SimVtx, hitEB, trkInfo, timeCut, debug);
    std::map<std::string,double> eEESimInfo = spr::eCaloSimInfo(geo, hitsEE, SimTk, SimVtx, hitEE, trkInfo, timeCut, debug);

    std::map<std::string, double> simInfo;
    simInfo.insert( std::pair<std::string, double>("eMatched",    (eEBSimInfo["eMatched"]+eEESimInfo["eMatched"])) );
    simInfo.insert( std::pair<std::string, double>("pdgMatched",  (eEBSimInfo["pdgMatched"]+eEESimInfo["pdgMatched"])) );
    simInfo.insert( std::pair<std::string, double>("eGamma",      (eEBSimInfo["eGamma"]+eEESimInfo["eGamma"])) );
    simInfo.insert( std::pair<std::string, double>("eNeutralHad", (eEBSimInfo["eNeutralHad"]+eEESimInfo["eNeutralHad"])) );
    simInfo.insert( std::pair<std::string, double>("eChargedHad", (eEBSimInfo["eChargedHad"]+eEESimInfo["eChargedHad"])) );
    simInfo.insert( std::pair<std::string, double>("eRest",       (eEBSimInfo["eRest"]+eEESimInfo["eRest"])) );
    simInfo.insert( std::pair<std::string, double>("eTotal",      (eEBSimInfo["eTotal"]+eEESimInfo["eTotal"])) );
    if (debug) {
      std::cout << " Matched " << eEBSimInfo["eMatched"] << "|" 
                << eEESimInfo["eMatched"] << "|" << simInfo["eMatched"]
                << "  energyGamma " << eEBSimInfo["eGamma"] << "|"
                << eEESimInfo["eGamma"] << "|" << simInfo["eGamma"]
	        << "  energyNeutral " << eEBSimInfo["eNeutralHad"] << "|"
                << eEESimInfo["eNeutralHad"] << "|" << simInfo["eNeutralHad"]
                << "  energyCharged " << eEBSimInfo["eChargedHad"] << "|"
                << eEESimInfo["eChargedHad"] << "|" << simInfo["eChargedHad"]
                << "  energyRest " << eEBSimInfo["eRest"] << "|" 
                << eEESimInfo["eRest"] << "|" << simInfo["eRest"]
                << "  energyTot " << eEBSimInfo["eTotal"] << "|"
                << eEESimInfo["eTotal"] << "|" << simInfo["eTotal"] 
	        << std::endl;
    }
    return simInfo;
  }

  template <typename T>
  std::map<std::string,double> eCaloSimInfo(const CaloGeometry* geo, edm::Handle<T>& hits, edm::Handle<edm::SimTrackContainer>& SimTk, edm::Handle<edm::SimVertexContainer>& SimVtx, std::vector< typename T::const_iterator> hit,  edm::SimTrackContainer::const_iterator trkInfo, double timeCut, bool debug){

    int matchedId = 0;         //pdgid

    if (debug) {
      if( trkInfo != SimTk->end()) std::cout <<"In eCaloSimInfo::  matchSimTrk:"<< trkInfo->trackId() << " matchedId " << trkInfo->type() << std::endl;
      else                         std::cout <<"In eCaloSimInfo::  not valid track pointer" << std::endl;
    }

    double energySum = 0.0;
    double energyGamma=0.0, energyNeutral=0.0, energyCharged=0.0, energyRest=0.0;

    if (trkInfo != SimTk->end()) {

      unsigned int matchSimTrk = trkInfo->trackId();
      matchedId                = trkInfo->type();         //pdgid

      edm::SimTrackContainer::const_iterator simTrkItr;
      edm::SimVertexContainer::const_iterator simVtxItr;
    
      for (unsigned int ihit=0; ihit<hit.size(); ihit++) {

	DetId id_ = (DetId)(hit[ihit]->id());
        double tof = timeOfFlight(id_, geo, debug);
	bool ok = true;
	if (((int)(id_.det())==4) && (id_.subdetId()==(int)(HcalForward))) ok = false;
        if ((hit[ihit]->time() <= (tof+timeCut)) && ok) {

    	 // if the hitId matches with matching trackId
          if (hit[ihit]->geantTrackId() == (int)matchSimTrk ) {
	    energySum += hit[ihit]->energy();
          } else { 
         // trace back the history and check the pdgId of origin SimTrack of SimHit
	    bool found = false;
	    for (simTrkItr = SimTk->begin(); simTrkItr!= SimTk->end(); simTrkItr++) {
	      if (hit[ihit]->geantTrackId() == (int)simTrkItr->trackId()) {
  	        found = true;
	        bool match = spr::validSimTrack(matchSimTrk, simTrkItr, SimTk, SimVtx, debug);
 	        if      (match) {energySum += hit[ihit]->energy();}
	        else {
	          edm::SimTrackContainer::const_iterator parentItr =  spr::parentSimTrack(simTrkItr, SimTk, SimVtx, debug); 
	          if (debug) {
                    if (parentItr != SimTk->end() ) std::cout << "original parent of " << simTrkItr->trackId() << " " << parentItr->trackId() << ", " << parentItr->type() << " Energy " << hit[ihit]->energy() << std::endl;
                    else                            std::cout << "original parent of " << simTrkItr->trackId() << " not found; Energy " << hit[ihit]->energy() << std::endl;
                  }
	          if (parentItr == SimTk->end() )        { energyRest += hit[ihit]->energy();}
	          else if (parentItr->type()  == 22)     { energyGamma += hit[ihit]->energy();}
	          else if ((int)parentItr->charge()== 0) { energyNeutral += hit[ihit]->energy();}
	          else                                     energyCharged += hit[ihit]->energy();
	        }
	        break;
	      } 
	    }
	    if (!found) energyRest += hit[ihit]->energy();
	    if (debug) std::cout << "Hit " << ihit << ": " << *hit[ihit] << std::endl;
          }
        }
      } // loop over hits
    }

    double energyTot = energySum+energyGamma+energyNeutral+energyCharged+energyRest;
    std::map<std::string, double> simInfo;
    simInfo.insert( std::pair<std::string, double>("eMatched",    energySum) );
    simInfo.insert( std::pair<std::string, double>("pdgMatched",  matchedId) );
    simInfo.insert( std::pair<std::string, double>("eGamma",      energyGamma) );
    simInfo.insert( std::pair<std::string, double>("eNeutralHad", energyNeutral) );
    simInfo.insert( std::pair<std::string, double>("eChargedHad", energyCharged) );
    simInfo.insert( std::pair<std::string, double>("eRest",       energyRest) );
    simInfo.insert( std::pair<std::string, double>("eTotal",      energyTot) );
    if (debug) {
      std::cout << " energySum " << energySum << "  energyGamma " << energyGamma 
	        << "  energyNeutral " << energyNeutral << "  energyCharged " 
                << energyCharged << "  energyRest " << energyRest 
                << "  energyTot " << energyTot << std::endl;
    }
    return simInfo;
  }

  // Returns total energy of CaloSimHits which originate from the matching SimTrack
  template <typename T>
  double eCaloSimInfo(const edm::Event& iEvent, const CaloGeometry* geo, edm::Handle<T>& hits, edm::Handle<edm::SimTrackContainer>& SimTk, edm::Handle<edm::SimVertexContainer>& SimVtx, const reco::Track* pTrack, TrackerHitAssociator& associate, double timeCut, bool debug) {
	
    // 	
    std::vector<int> matchedId = spr::matchedSimTrackId(iEvent, SimTk, SimVtx, pTrack, associate, debug);
    double energySum = 0.0;
    if (debug) {
      std::cout << "eCaloSimInfo:: Found " << matchedId.size() << " track IDs originating from the current track";
      for (unsigned int it = 0; it < matchedId.size(); ++it) 
        std::cout << " " << matchedId[it];
      std::cout << std::endl;
    }
    if (matchedId.size() > 0) {
      typename T::const_iterator ihit;
      for (ihit=hits->begin(); ihit!=hits->end(); ihit++) {

        //cut on time
	DetId id_ = (DetId)(ihit->id());
        double tof = timeOfFlight(id_, geo, debug);
	bool ok = true;
	if (((int)(id_.det())==4) && (id_.subdetId()==(int)(HcalForward))) ok = false;
        if ((ihit->time() <= (tof+timeCut)) && ok) {

          int  id = ihit->geantTrackId();
          bool found = false;
          for (unsigned int it = 0; it < matchedId.size(); ++it) {
	    if (id == matchedId[it]) {
	      found = true; break;
	    }
          }
          if (found) {
	    energySum += ihit->energy();
	    if (debug) std::cout << "Hit " << *ihit << std::endl;
          }
        }
      }
    }
    return energySum;
  }

  template <typename T>
  double eCaloSimInfo(const edm::Event& iEvent, const CaloGeometry* geo, edm::Handle<T>& hitsEB, edm::Handle<T>& hitsEE, edm::Handle<edm::SimTrackContainer>& SimTk, edm::Handle<edm::SimVertexContainer>& SimVtx, const reco::Track* pTrack, TrackerHitAssociator& associate, double timeCut, bool debug) {
	
    // 	
    std::vector<int> matchedId = spr::matchedSimTrackId(iEvent, SimTk, SimVtx, pTrack, associate, debug);
    double energySum = 0.0;
    if (debug) {
      std::cout << "eCaloSimInfo:: Found " << matchedId.size() << " track IDs originating from the current track";
      for (unsigned int it = 0; it < matchedId.size(); ++it) 
        std::cout << " " << matchedId[it];
      std::cout << std::endl;
    }
    if (matchedId.size() > 0) {
      typename T::const_iterator ihit;
      for (ihit=hitsEB->begin(); ihit!=hitsEB->end(); ihit++) {

        //cut on time
        double tof = timeOfFlight((DetId)(ihit->id()), geo, debug);
        if (ihit->time() <= (tof+timeCut)) {

          int  id = ihit->geantTrackId();
          bool found = false;
          for (unsigned int it = 0; it < matchedId.size(); ++it) {
	    if (id == matchedId[it]) {
	      found = true; break;
	    }
          }
          if (found) {
	    energySum += ihit->energy();
	    if (debug) std::cout << "Hit " << *ihit << std::endl;
          }
        }
      }
      for (ihit=hitsEE->begin(); ihit!=hitsEE->end(); ihit++) {

        //cut on time
        double tof = timeOfFlight((DetId)(ihit->id()), geo, debug);
        if (ihit->time() <= (tof+timeCut)) {

          int  id = ihit->geantTrackId();
          bool found = false;
          for (unsigned int it = 0; it < matchedId.size(); ++it) {
	    if (id == matchedId[it]) {
	      found = true; break;
	    }
          }
          if (found) {
	    energySum += ihit->energy();
	    if (debug) std::cout << "Hit " << *ihit << std::endl;
          }
        }
      }
    }
    return energySum;
  }

  template <typename T>
  std::vector<typename T::const_iterator> missedECALHits(const edm::Event& iEvent, CaloNavigator<DetId>& navigator, edm::Handle<T>& hits,edm::Handle<edm::SimTrackContainer>& SimTk, edm::Handle<edm::SimVertexContainer>& SimVtx, const reco::Track* pTrack, TrackerHitAssociator& associate, int ieta, int iphi, bool flag, bool debug) {

    if (debug) {
      std::cout << "Processing missedECALHits " << 2*ieta+1 << "x" << 2*iphi+1 << " and Flag " << flag << std::endl;
      std::cout << "trkMom " << pTrack->p() << " eta " << pTrack->eta() << " trkRecHits " << pTrack->recHitsSize() << std::endl;
    }

    edm::SimTrackContainer::const_iterator trkInfo = spr::matchedSimTrack(iEvent, SimTk, SimVtx, pTrack, associate, debug);

    std::vector< typename T::const_iterator> ecalHits   = spr::hitECALmatrix(navigator,hits,ieta,iphi,debug);

    std::vector<int> matchedId = spr::matchedSimTrackId(iEvent, SimTk, SimVtx, pTrack, associate, debug);

    return spr::missedCaloHits(hits, matchedId, ecalHits, flag, debug);
  }

  template <typename T>
  std::vector<typename T::const_iterator> missedHCALHits(const edm::Event& iEvent, const HcalTopology* topology, const DetId& det, edm::Handle<T>& hits,edm::Handle<edm::SimTrackContainer>& SimTk, edm::Handle<edm::SimVertexContainer>& SimVtx, const reco::Track* pTrack, TrackerHitAssociator& associate, int ieta, int iphi, bool flag, bool debug) {

    if (debug) {
      std::cout << "Processing missedHCALHits " << 2*ieta+1 << "x" << 2*iphi+1 << " and Flag " << flag << std::endl;
      std::cout << "trkMom " << pTrack->p() << " eta " << pTrack->eta() << " trkRecHits " << pTrack->recHitsSize() << std::endl;
    }

    edm::SimTrackContainer::const_iterator trkInfo = spr::matchedSimTrack(iEvent, SimTk, SimVtx, pTrack,associate, debug);

    std::vector< typename T::const_iterator> hit = spr::hitHCALmatrixNew(topology,det,hits,ieta,iphi,false, debug);

    std::vector<int> matchedId = spr::matchedSimTrackId(iEvent, SimTk, SimVtx, pTrack, associate, debug);

    return spr::missedCaloHits(hits, matchedId, hit, flag, debug);
  }

  template <typename T>
  std::vector<typename T::const_iterator> missedCaloHits(edm::Handle<T>& hits, std::vector<int> matchedId, std::vector< typename T::const_iterator> caloHits, bool flag, bool debug ) {

    std::vector<typename T::const_iterator> missedHits;
    std::vector<typename T::const_iterator> usedHits;
    if (matchedId.size() > 0) {
      typename T::const_iterator ihit;
      for (ihit=hits->begin(); ihit!=hits->end(); ihit++) {
        int  id = ihit->geantTrackId();
        bool found = false;
        for (unsigned int it = 0; it < matchedId.size(); ++it) {
	  if (id == matchedId[it]) {
	    found = true; break;
	  }
        }
        if (found) {
	  if (flag) {
	    if (count(caloHits.begin(),caloHits.end(),ihit) == 0) missedHits.push_back(ihit);
          } else {
            usedHits.push_back(ihit);
          }
        }
      }
    }
    if (!flag) {
      for (unsigned int ii=0; ii<caloHits.size(); ii++) {
        if (count(usedHits.begin(),usedHits.end(),caloHits[ii]) == 0) missedHits.push_back(caloHits[ii]);
      }
    }
    if (debug) {
      std::cout << "missedCaloHits finds " << missedHits.size() << " missed hits" << std::endl;
      for (unsigned int i=0; i<missedHits.size(); i++)
        std::cout << "Hit " << i << " " << *missedHits[i] << std::endl;
    }
    return missedHits;
  }

}
